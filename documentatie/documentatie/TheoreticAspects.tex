\chapter{Theoretical aspects}

\section{Software dependencies}
A dependency is created by two elements that are in a relationship and indicates that an element of the relationship, in some manner, depends on the other element of the relationship. In this case, if one of these elements change, there could be an impact to the other \cite{ct2}. Dependencies are discovered by analysis of source code or from an intermediate representation such as abstract syntax trees \cite{ct3} . In order to build structural and logical dependencies we have developed a tool that takes as input the source code repository and builds the required software dependencies . The workﬂow can be delimited by three major steps as it follows  (Figure \ref{fig:fig3}):  \\
\textit{\textbf{Step 1:} Extracting structural dependencies.}\\
\textit{\textbf{Step 2:} Extracting logical dependencies.}\\
\textit{\textbf{Step 3:} Processing the information extracted.}

\section{Structural dependencies}

 Structural dependencies (a.k.a syntactic dependencies or structural coupling) are the result of source code analysis. Each source code ﬁle can contain one or more classes. There are several types of relationships between source code entities, a method can call another class method, a class extends another class, all those create dependencies between classes  \cite{ct4}].\\
\tab Even though in some of the cases if class A depends on class B , changes in class B can produce changes in class A, but not the other way around \cite{ct5} . There are other cases in which if class A depends on class B,changes in class B can produce changes in class A and viceversa if we are speaking in the context of a new feature implementation that implies changing return types and adding new methods. So we will consider structural dependencies as bidirectional relationships, "classA depends on class B" and "class B depends on class A".\\ The choice of building bidirectional relationships is motivated by the fact that we cannot establish for the moment the direction of the logical dependencies of the system. So in order to have a omogeninty between the logical and structural dependencies analysis results, we will take both of the relationships types as bidirectional. 

\section{Logical dependencies}
\subsection{Version control systems}
In computer software engineering, revision control is any kind of practice that tracks and provides control over changes to source code. Software developers sometimes use revision control software to maintain documentation and source code.\\
At a basic level, developers could retain multiple copies of the different versions of the program and label them appropriately. This method can work but it is inefficient as many copies of the program have to be maintained. Because of this, systems to automate some or all of the revision control process have been developed. 
\\ 
\tab Among the keywords used in a versioning system we can mention:\\
\textit{\textbf{Repository}} -  is a virtual storage of a project. It allows to save versions of the code, which can be access when needed.\\
\textit{\textbf{Master/Trunk}} - the main body of development, originating from the start of the project until the present.\\
\textit{\textbf{Branch} }- a copy of code derived from a certain point in the master that is used for applying major changes to the code while preserving the integrity of the code in the master. The changes are usually merged back into the master.\\
\textit{\textbf{Revision}} - changes are usually identified by a number or letter code, that code is known as "revision".\\




\subsection{Definition}
The versioning system contains the long-term change history of every file. Each project change made by an individual at certain point of time is contained into a commit \cite{ct7}.\\ All the commits are stored in the versioning system cronologicaly and each commit has a parent. The parent commit is the baseline from which development began, the only exeption to this rule is the first commit which has no parent. We will take into consideration only \textit{commits that have a parent} since the first commit can include source code files that are already in development (migration from one versioning system to another) and this can introduce reduntant logical links \cite{ct8} .\\ The tool looks through the main branch of the project and gets all the existing commits, for each commit a diff against the parent will be made and stored.\\ Finally after all the differences files are stored , all the files are parsed and logical dependencies are build. In addition , the number of files changed in a commit can influence the logical dependencies. A relatively big number of files changed can indicate a merge of all changes from another branch as a single commit. This can lead to a number of logical dependencies that are redundant since the files are not actualy changing in the same time.The logical dependencies are splitted into three categories :\\
\textit{\textbf{Category 1:} Dependencies found in commits with less than 5 source code files changed.}\\
\textit{\textbf{Category 2:} Dependencies found in commits with more than 5 files changed but less than 20. }\\
\textit{\textbf{Category 3:} Dependencies found in commits with more than 20 files.}\\

Also for each category two dependencies analysis will be made:
\textit{\textbf{A:} Considering comments  as valid changes.}
\textit{\textbf{B:} Considering comments  as redundant changes. }
In the second case if class A and class B change together but the only change found is a comment change then between class A and B will not be set logical dependency.
